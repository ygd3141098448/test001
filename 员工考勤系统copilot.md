# 第四章：用例建模

**[综合案例:员工考勒系统]**
现要为某单位开发一款“ 员工考勤系统”，其开发背景和问题陈述如下。根据该系统陈述和对相关业务的理解，完成系统**用例图**和**核心用例的用例文档**。

作为Acme公司的信息主管，你被委托开发一款新的考勤系统 。要求新系统允许员工记录电子的考勤信息并自动产生员工的工资支付信息。

新系统运行在整个公司内部的每名员工的计算机上，考虑到安全和隐私方面的原因，每名员工只能访问和编辑自己的考勤信息和工资支付信息,但是项目经理可以查看和编辑本项目组内部所有员工的信息。

新系统用于维护公司内部所有的员工信息(目前公司大约有5000多名员工)，系统必须能够按照员工的考勤信息按时正确地计算工资信息。由于费用原因，目前公司并不打算替换已有的遗留数据库系统一项目管理数据库。在该数据库中保存着公司所有的项目信息及相关的工资级别代码,属于不同项目的员工，其工资的计算方式并不相同(根据工资级别代码来区分)。该数据库采用的是运行在IBM主机上的DB2系统。考勤系统需要访问该数据库的信息,但不进行更新操作。

公司内部按项目组的形式管理，项目经理负责整个项目组;而组内一.般存在3类雇员。

第一类为小时工,其工资按照小时计算。他们每天需要记录当天的工作小时，根据工作时间和所属项目的工资级别代码来计算当天的工资;如果当天工作超过8小时，则超过的部分按加班计算(工资为平时的1.5倍)。这类员工每周五结算本周工资。

第二类为普通员工，其工资每月固定。为了跟踪他们的上班情况，他们每天也需要记录当天的工作时间，某些项目组可能会根据该工作时间对员工进行奖惩(具体奖惩措施本系统不处理，由项目经理自行决定)。这类员工每个月末结算工资。

第三类为销售人员,这类员工不用每天记录考勤信息，而是记录当天完成的订单情况。其工资的计算方式是根据当月的订单情况进行提成。根据订单的性质不同，提成的比例也有所差别，具体提成比例有5%、10%、15%、25%这4个档次。这类员工工资也是在每个月末结算。

新系统另一个最重要的特征就是所有的员工可以随时查看自己的考勤信息，对于员工而言，提交的考勤信息不允许修改(如果实在存在错误，可由项目经理修改):在每个月末(对于小时工则为每个周末)，还可以查看自己本月的工资支付信息(以前的工资信息可随时查看)。

为了保证员工能够及时地获得本月的工资情况，该系统在每个周五和每个月末会自动运行，为员工产生相应的工资信息，并及时提醒项目经理确认工资信息。经项目经理确认后的工资信息即可公开给员工。

**用例图：**

```plaintext
参与者: 员工, 项目经理

用例:
1. 记录考勤信息
2. 查看考勤信息
3. 查看工资支付信息
4. 编辑考勤信息 (仅限项目经理)
5. 确认工资信息 (仅限项目经理)

关系:
- 员工 -> 记录考勤信息
- 员工 -> 查看考勤信息
- 员工 -> 查看工资支付信息
- 项目经理 -> 查看考勤信息
- 项目经理 -> 查看工资支付信息
- 项目经理 -> 编辑考勤信息
- 项目经理 -> 确认工资信息
```

**核心用例的用例文档：**

1. **用例名称：** 记录考勤信息
   * 参与者： 员工
   * 前置条件： 员工已登录系统
   * 后置条件： 考勤信息已记录
   * 主成功场景： 员工登录系统，输入当天的考勤信息，系统保存考勤信息
   * 扩展： 如果员工输入的考勤信息不符合规则，系统将提示错误信息
2. **用例名称：** 查看考勤信息
   * 参与者： 员工，项目经理
   * 前置条件： 员工或项目经理已登录系统
   * 后置条件： 考勤信息已显示
   * 主成功场景： 员工或项目经理登录系统，请求查看考勤信息，系统显示考勤信息
3. **用例名称：** 查看工资支付信息
   * 参与者： 员工，项目经理
   * 前置条件： 员工或项目经理已登录系统
   * 后置条件： 工资支付信息已显示
   * 主成功场景： 员工或项目经理登录系统，请求查看工资支付信息，系统显示工资支付信息
4. **用例名称：** 编辑考勤信息
   * 参与者： 项目经理
   * 前置条件： 项目经理已登录系统
   * 后置条件： 考勤信息已更新
   * 主成功场景： 项目经理登录系统，选择要编辑的考勤信息，修改信息，系统保存更新的考勤信息
   * 扩展： 如果项目经理输入的考勤信息不符合规则，系统将提示错误信息
5. **用例名称：** 确认工资信息
   * 参与者： 项目经理
   * 前置条件： 项目经理已登录系统
   * 后置条件： 工资信息已确认
   * 主成功场景： 项目经理登录系统，查看工资信息，确认无误后，系统保存确认的工资信息
   * 扩展： 如果项目经理发现工资信息有误，可以选择编辑考勤信息，然后再次确认工资信息


# 第五章：用例分析

**[综合案例:员工考勤系统]**

在第4章已经完成的该系统用例模型基础上，完成分析过程。

(1 )简单描述系统的备选构架,并将分析过程所发现的类放人到相应的层次结构中。

(2)针对系统的核心用例，完成用例分析工作，每个用例实现模型至少应包括:

(2.1)描述基本路径的交互

(2.2)用例实现的参与类类图

(3)构造系统完整的实体类类图。

**(1) 系统的备选构架可以分为三层：表示层、业务逻辑层和数据访问层。在这个架构中，我们可以将发现的类放入相应的层次结构中：**

* 表示层 ：员工界面，项目经理界面
* 业务逻辑层 ：考勤管理，工资计算
* 数据访问层 ：员工数据访问，项目数据访问

**(2) 针对系统的核心用例“记录考勤信息”，完成用例分析工作：**

**(2.1) 基本路径的交互描述：**

* 员工登录系统
* 员工选择“记录考勤信息”选项
* 系统显示考勤信息输入界面
* 员工输入考勤信息
* 系统验证考勤信息
* 系统保存考勤信息
* 系统显示考勤信息已保存的确认信息

**(2.2) 用例实现的参与类类图：**

```plaintext
+----------------+       +----------------+
|   Employee     |       | AttendanceInfo |
+----------------+       +----------------+
| -employeeId    |<------|-employeeId     |
| -name          |       |-date           |
| -project       |       |-hoursWorked    |
+----------------+       +----------------+
```

(3) 系统完整的实体类类图：

```plaintext
+----------------+       +----------------+       +----------------+
|   Employee     |       | AttendanceInfo |       |   Project      |
+----------------+       +----------------+       +----------------+
| -employeeId    |<------|-employeeId     |       |-projectId      |
| -name          |       |-date           |       |-projectName    |
| -project       |------>|-hoursWorked    |<------|-wageCode       |
+----------------+       +----------------+       +----------------+
```

在这个类图中，Employee类代表员工，每个员工有一个唯一的employeeId和名字，以及他们所在的项目。AttendanceInfo类代表考勤信息，包括员工ID、日期和工作小时数。Project类代表项目，每个项目有一个唯一的projectId、项目名称和工资代码。员工和项目之间是一对多的关系，员工和考勤信息之间是一对多的关系，项目和考勤信息之间是一对多的关系。这个类图表示了系统的主要实体及其关系。注意，这只是一个简化的类图，实际的系统可能会有更多的类和更复杂的关系。例如，可能需要一个单独的类来表示工资信息，或者一个类来表示不同类型的员工（如小时工、普通员工和销售人员）。这个类图应该根据实际的需求和设计来调整。

# 第八章：架构设计

**[综合案例:员工考勤系统]**

结合已经完成的需求和分析模型，以本章介绍的架构设计方法,设计该**系统架构**。

在设计员工考勤系统的架构时，我们可以采用分层架构模式，这种模式将系统分为表示层、业务逻辑层和数据访问层。以下是这三层的详细描述：

1. **表示层** ：这一层负责处理用户界面和用户交互。在我们的考勤系统中，表示层包括员工界面和项目经理界面。员工界面允许员工记录考勤信息和查看自己的考勤和工资信息。项目经理界面允许项目经理查看和编辑项目组内所有员工的考勤和工资信息。
2. **业务逻辑层** ：这一层包含了系统的核心功能，即业务规则和业务流程。在我们的考勤系统中，业务逻辑层包括考勤管理和工资计算。考勤管理负责处理员工的考勤信息，包括记录考勤信息和查看考勤信息。工资计算负责根据员工的考勤信息和项目的工资级别代码计算员工的工资。
3. **数据访问层** ：这一层负责处理数据存储和检索。在我们的考勤系统中，数据访问层包括员工数据访问和项目数据访问。员工数据访问负责处理员工的个人信息，包括员工的姓名、项目和考勤信息。项目数据访问负责处理项目信息，包括项目的名称和工资级别代码。

这种分层架构模式有助于提高系统的可维护性和可扩展性。表示层、业务逻辑层和数据访问层之间的清晰分界使得我们可以独立地修改和扩展每一层。例如，我们可以改变数据访问层以适应新的数据库系统，而不影响业务逻辑层和表示层。同样，我们也可以改变表示层以提供新的用户界面，而不影响业务逻辑层和数据访问层。

请注意，这只是一个基本的架构设计。在实际的系统开发过程中，可能需要更详细和复杂的架构设计，以满足所有的需求和约束。例如，我们可能需要考虑如何处理并发访问、如何提高系统的性能和可用性、如何保护数据的安全和隐私等问题。这些问题的解决方案可能会影响到架构设计的选择和实现。因此，架构设计应该是一个持续和迭代的过程，需要根据系统的需求和约束进行调整和优化。

在这个过程中，我们应该遵循一些基本的架构设计原则，例如模块化、抽象、封装、分离关注点等，以帮助我们设计出高质量的系统架构。同时，我们也应该利用一些架构设计方法和工具，例如用例分析、类图、序列图、状态图等，以帮助我们理解和表达系统的需求和设计。通过这样的方式，我们可以确保我们的架构设计能够满足系统的需求，同时也能够适应未来的变化和挑战。

# 第九章：构建设计

[综合案例:员工考勤系统]

基于已经完成的分析和设计工作，完成该系统的构件设计。

(1))针对系统的核心用例，完成用例设计工作.每个用例实现模型至少应包括:

1.1描述基本路径的交互

1.2用例实现的参与类类图

(2)完成系统的数据库设计。

**(1) 针对系统的核心用例“记录考勤信息”，完成用例设计工作：**

**1.1 基本路径的交互描述：**

* 员工登录系统
* 员工选择“记录考勤信息”选项
* 系统显示考勤信息输入界面
* 员工输入考勤信息
* 系统验证考勤信息
* 系统保存考勤信息
* 系统显示考勤信息已保存的确认信息

**1.2 用例实现的参与类类图：**

```plaintext
+----------------+       +----------------+
|   Employee     |       | AttendanceInfo |
+----------------+       +----------------+
| -employeeId    |<------|-employeeId     |
| -name          |       |-date           |
| -project       |       |-hoursWorked    |
+----------------+       +----------------+
```

**(2) 完成系统的数据库设计：**

在数据库设计中，我们需要为每个实体类创建一个表。每个表包含一个主键和一些属性，主键用于唯一标识表中的每一行，属性对应于实体类的属性。在我们的考勤系统中，我们需要创建以下三个表：

* **Employee** 表：包含 employeeId（主键）、name 和 project 属性。
* **AttendanceInfo** 表：包含 employeeId（外键，引用 Employee 表的 employeeId）、date（主键）和 hoursWorked 属性。
* **Project** 表：包含 projectId（主键）、projectName 和 wageCode 属性。

此外，我们还需要创建一些索引以提高查询的性能。例如，我们可以在 Employee 表的 name 属性上创建一个索引，以便快速查找特定姓名的员工。我们也可以在 AttendanceInfo 表的 date 属性上创建一个索引，以便快速查找特定日期的考勤信息。

请注意，这只是一个基本的数据库设计。在实际的系统开发过程中，可能需要更详细和复杂的数据库设计，以满足所有的需求和约束。

例如，我们可能需要考虑如何处理并发访问、如何提高数据库的性能和可用性、如何保护数据的安全和隐私等问题。这些问题的解决方案可能会影响到数据库设计的选择和实现。因此，数据库设计应该是一个持续和迭代的过程，需要根据系统的需求和约束进行调整和优化。

在这个过程中，我们应该遵循一些基本的数据库设计原则，例如规范化、抽象、封装、分离关注点等，以帮助我们设计出高质量的数据库。同时，我们也应该利用一些数据库设计方法和工具，例如实体-关系模型、关系模型、SQL等，以帮助我们理解和表达数据库的需求和设计。通过这样的方式，我们可以确保我们的数据库设计能够满足系统的需求，同时也能够适应未来的变化和挑战。
